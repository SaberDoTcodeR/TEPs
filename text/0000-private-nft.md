- **TEP**: [0](https://github.com/ton-blockchain/TEPs/pull/0) *(don't change)*
- **title**: Private NFT Standard *(ZK)*
- **status**: Draft
- **type**: Contract Interface
- **authors**: [Saber](https://github.com/SaberDoTcodeR)
- **created**: 01.08.2023
- **replaces**: [TEP-62](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md)
- **replaced by**: -

# Summary

A Standard on top of TON NFT standard to enable private transfers and private ownership of NFTs using Zero-Knowledge.

# Motivation

TON NFT standard is a great standard for NFTs, but it lacks privacy. As an example, if Alice owns a Telegram Anonymous Number/ Telegram Username NFT, her TON Identity will be fully linked to her Telegram identity. 
There should be an option for users to preserve their privacy while their ownership of NFTs is still verifiable fully on-chain.

Additional feature on top of TON NFT standard are:

- Private Transfer of NFT ownership without revealing the sender, receiver, or the NFT Item itself.
- An option for NFT owners to reveal their ownership(like normal TON NFTs)
- An option for NFT owners to shield their ownership after they reveal it.
- Generation of a Zero-Knowledge Proof for the NFT ownership(verifiable off-chain for third parties)

# Guide

As mentioned in the [TEP-62](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#guide), Non-Fungible Token (NFT) represents an ownership over unique digital asset. And based on that implementation there are 1 NFT Collection and N NFT Item contracts. Each deployed NFT Item contract has an owner address in their datacell. In this standard we will avoid that and prove ownership only with Zero Knowledge Proofs.

NFT items can be transferred privately or revealed by using a Zero-Knowledge Proof(ZKP) which can only be generated by the secret key owner.

## Useful links
1. [Reference Private NFT contract implementation](https://github.com/SaberDoTcodeR/Tonnel-Network/blob/main/contracts/ZK%20NFT/nft-collection.fc)
2. [Reference Private NFT Circom implementation](https://github.com/SaberDoTcodeR/Tonnel-Network/tree/main/circuits)
3. [A more detailed explanation of the implementation](https://telegra.ph/Private-NFTs-is-it-Myth-or-Math-08-27)
4. [A demo of the implementation](https://t.me/Tonnel_Network_bot)

# Specification

NFT Item contract will stay intact, but the NFT Collection contract will be modified to support Private Transfers, Reveal and Shield.

Commitment = Hash(Secret, TokenId)
Nullifier = Hash(TokenId, Secret)

## NFT Item Contract
It will be exactly the same as the [TEP-62](https://github.com/ton-blockchain/TEPs/blob/master/text/0062-nft-standard.md#nft-item-smart-contract) implementation. We won't need to change anything here.

## NFT Collection Contract

Besides the already implemented functions, we will add the following functions:

Must implement:

### Internal message handlers
### 1. `private_transfer`


<img src="../assets/0000-private-nft/transferPrivate.png" alt="Private Transfer" width="1000"/>


**Request**
To preserve privacy of the sender, a relayer should this message to the NFT Collection contract on behalf of the NFT Item Owner. 
TL-B schema of inbound message:

```
private_transfer#777 query_id:uint64 proof_payload:^ProofPayload = InternalMsgBody;

_ root:uint256 nullifier:uint256 newCommitment:uint256 proof_points:^[ pi_a:^[ a: (## 384)] pi_b:^[ b: (## 768)] pi_c:^[ c: (## 384)] ] = ProofPayload;
  ```

`query_id` - arbitrary request number.

`proof_payload` - proof payload cell required for the proof verification.

`root` - root of the Merkle Tree *(Implementation will be explained later)*

`nullifier` - to avoid double spending, we will use a nullifier to mark the commitment as spent. You can't map a nullifier to a commitment!

`newCommitment` - the new commitment that will own the NFT Item after the transfer.

`proof_points` - the proof points that will be used in the pairing check to verify the proof. It can only be generated by the secret key owner.

**Should be rejected if:**

1. if any of the inputs are bigger than bls12-381 curve order *(52435875175126190479447740508185965837690552500527637822603658699938581184513)*.
2. if the nullifier is already spent.
3. if the root is not the same as any of the roots in the History Merkle Tree.
4. if the proof is not valid and the pairing check fails.

**Otherwise should do:**

1. insert the newCommitment to the History Merkle Tree.
2. mark the nullifier as spent.


### 2. `reveal`
**Request**


<img src="../assets/0000-private-nft/revealNFT.png" alt="Reveal NFT" width="1000"/>


TL-B schema of inbound message:

```
reveal#888 query_id:uint64 proof_payload:^ProofPayload = InternalMsgBody;

_ root:uint256 nullifier:uint256 owner:MsgAddress token_id:uint32 proof_points:^[ pi_a:^[ a: (## 384)] pi_b:^[ b: (## 768)] pi_c:^[ c: (## 384)] ] = ProofPayload;
  ```

`query_id` - arbitrary request number.

`proof_payload` - proof payload cell required for the proof verification.

`root` - root of the Merkle Tree *(Implementation will be explained later)*

`nullifier` - to avoid double spending, we will use a nullifier to mark the commitment as spent. You can't map a nullifier to a commitment!

`owner` - the address of the owner of the NFT Item after the reveal.

`token_id` - the token id of the NFT Item.

`proof_points` - the proof points that will be used in the pairing check to verify the proof. It can only be generated by the secret key owner.

**Should be rejected if:**

1. if any of the inputs are bigger than bls12-381 curve order *(52435875175126190479447740508185965837690552500527637822603658699938581184513)*.
2. if the nullifier is already spent.
3. if the root is not the same as any of the roots in the History Merkle Tree.
4. if the proof is not valid and the pairing check fails.

**Otherwise should do:**

1. send a message to the NFT Item contract to change the owner to the new owner.
2. mark the nullifier as spent.


### 3. `shield`
**Request**

<img src="../assets/0000-private-nft/shieldNFT.png" alt="Reveal NFT" width="1000"/>


This is the forward payload of NFT item transfer to NFT collection contract. It will be used to shield(hide) the ownership of the NFT Item.

TL-B schema of inbound message:

```
ownership_assigned#05138d91 query_id:uint64 prev_owner:MsgAddress forward_payload:^ShieldMessage = InternalMsgBody;

_ commitment:uint256 token_id:uint32 = ShieldMessage;
  ```

`query_id` - arbitrary request number.

`commitment` - the commitment of the NFT Item which will be inserted to the History Merkle Tree.

`token_id` - the token id of the NFT Item.

**Should be rejected if:**

1. if the sender is not the NFT Item address.

**Otherwise should do:**

1. insert the commitment to the History Merkle Tree.



# Drawbacks

The main drawback of this implementation is that it will be more expensive than the normal TON NFT standard. It will require more gas to transfer the NFT Item privately(verify the proof using the bls12-381 pairing and insert commitment in merkle tree).

Also generating the proof is a very heavy computation, so it will require a strong hardware to generate the proof.

However, by adopting the ZK use case in TON Blockchain, TVM core team can add ZK friendly hash functions(for example MiMCsponge or Poseidon) to the TVM, which will make the proof generation much cheaper, and can significantly reduce the gas cost of the commitment insertion in the Merkle Tree(we currently use SHA256 for merkle tree).

# Rationale and alternatives

This solution is not the most straightforward solution, but it is certainly fully trust-less and fully private. There could be better implementations, but the main goal of this standard is to fix the privacy issue of the TON NFT standard.

This standard is fully compatible with the TON NFT standard, and every major NFT marketplace on TON. Supporting privacy features can be optional feature for NFT marketplaces.

# Prior art
.

# Unresolved questions

The need for a ZK friendly hash function in TVM core, also the incentive model for the relayers(who will relay the private transfer messages to the NFT Collection contract on behalf of the NFT Item owner).

# Future possibilities

* private NFT marketplace
* private NFT DAO voting mechanism